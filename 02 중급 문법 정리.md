# 프로젝션 결과 반환 - 기본 
> 프로젝션 select 대상 지정 

## 프로젝션 대상이 하나 

```kt
    @Test
    fun singleProjection() {
        val result: List<String> = queryFactory
            .select(member.username)
            .from(member)
            .fetch()
    }
```

* 프로젝션 대상이 하나면 타입을 명확하게 지정할 수 있음
* 프로젝션 대상이 둘 이상이면 튜플이나 DTO로 조회

## 프로젝션 대상이 여럿 - 튜플

```kt
    @Test
    fun tupleProjection() {
        val result: List<Tuple> = queryFactory
            .select(member.username, member.age)
            .from(member)
            .fetch()

        for (tuple in result) {
            val username = tuple.get(member.username)
            val age = tuple.get(member.age)
            println("username=" + username)
            println("age=" + age)
        }
    }
``` 

프로젝션이 여럿인 경우 튜플을 쓴다.(컬럼2개이상 or 엔티티2개 이상 반환시)  
  
## 프로젝션과 결과 반환 - DTO 조회  
> Querydsl 빈 생성(Bean population): 결과를 DTO 반환할 때 사용
   
**다음 3가지 방법 지원**
* 프로퍼티 접근
* 필드 직접 접근
* 생성자 사용

### Setter 사용
> 기본생성자가 필요하다
```kt
class MemberDto(var username: String? = null, var age: Int? = null)
```
```kt
    @Test
    fun projectionBean() {
        val result = queryFactory
            .select(
                Projections.bean(
                    MemberDto::class.java,
                    member.username,
                    member.age
                )
            )
            .from(member)
            .fetch()
    }
```    

### 필드 사용 
> 기본생성자가 필요하다
```kt
class MemberDto(var username: String? = null, var age: Int? = null)
```

```kt
    @Test
    fun projectionField() {
        val result = queryFactory
            .select(
                Projections.fields(
                    MemberDto::class.java,
                    member.username,
                    member.age
                )
            )
            .from(member)
            .fetch()
    }
```

### 생성자 사용 
> 기본생성자가 필요하지 않다(생성 리플랙션 안하므로)    
> 당연하겠지만 타입을 맞춰줘야 한다 -> 이름이 달라도 된다.  
   
```kt
class MemberDto(val username: String, val age: Int)
```
```kt
    @Test
    fun projectionConstructor() {
        val result = queryFactory
            .select(
                Projections.constructor(
                    MemberDto::class.java,
                    member.username,
                    member.age
                )
            )
            .from(member)
            .fetch()
    }
```

### 프로퍼티랑 이름이 다른 경우 

```kt
class MemberDto(var name: String? = null, var age: Int? = null)
```
```kt
    @Test
    fun ProjectionsdiffrenName() {
        val memberSub = QMember("memberSub")
        val fetch = queryFactory
            .select(
                Projections.fields(
                    MemberDto::class.java,
                    member.username.`as`("name"),
                    ExpressionUtils.`as`(
                        JPAExpressions
                            .select(memberSub.age.max())
                            .from(memberSub), "age"
                    )
                )
            ).from(member)
            .fetch()
    }
```  
.as()로 알맞는 프로퍼티 이름을 기입해주면 된다.     
